package at.ik;

import android.annotation.SuppressLint;

/**
 * This code generator uses a brute force algorithm to find 10 000 valid
 * activation and response key pairs. The activation code is used for activating the Malware once installed
 * while the response code is used for generating the cipher key, which is later on used to encrypt the 
 * screen lock password.
 * 
 * Since the activation code is 6 digit long and uses a number sequence from 0 - 9
 * to generate the response code, which is again 6 digit long, we can safely assume that there are no
 * additional activation response key pairs, otherwise there would be conflicts translating the activation
 * key into a valid response code.
 * 
 * 999992 sets the limit of the last activation code, 
 * where the formula ((((digit_1 * 10) + digit_4) + ((digit_2 * 10) + digit_5)) * digit_3)) 
 * still yields a number (in the case of the last activation code this number is 0001782), 
 * where the last digit is equal to the last digit of the activation code
 * (in the case of the last activation code this is 2).
 *  
 *  After a successful instantiation, the counters of the six digits are reset to 0
 *  This class was designed to iterate through all key pairs using the generateNextKeyPair().
 *  The keys can be retrieved by calling the getActivation_code() and getResponse_code() member functions.
 *  
 *  All key pairs generated by this class should be valid without exceptions.
 * 
 * @author Tibor Éliás, BSc
 *
 */
public class CodeGenerator 
{
	// the number sequence that is used by the Malware to generate the response code
	final String strNumSequence = "7362095814";
	
	// The limit of one digit, this cannot exceed the size of the strNumSequence
	private final static int MAX_ATTEMPT = 10;
	
	// sets the limit of the last activation code
	public final static int LAST_ACTIVATION_KEY = 999992;
	
	// these are the counters used to calculate the next valid activation code
	private static int i; 
	private static int j;
	private static int k; 
	private static int l; 
	private static int m;
	private static int n;
	
	// stores the current valid activation code
	private static String strActivation_code;
	
	// stores the current valid response code
	private static String strResponse_code;
	
	/**
	 * The constructor resets the counters 
	 * and initializes the activation and the response codes
	 */
	public CodeGenerator()
	{
	  resetCodeGenerator();
	  
	  strActivation_code = "";
	  strResponse_code = "";
	}
	
	public String getActivation_code() {
		return strActivation_code;
	}

	public String getResponse_code() {
		return strResponse_code;
	}
	
	public void resetCodeGenerator()
	{
	  i = 0; 
	  j = 0;
	  k = 0; 
	  l = 0; 
	  m = 0;
	  n = 0;
	}
	
	public void generateNextKeyPair()
	{
		generateNextActivationCode();
		generateNextResponseCode();
	}
	
	@SuppressLint("DefaultLocale") 
	private String generateNextActivationCode()
	{
		strActivation_code = "";
		while (i < MAX_ATTEMPT)
		{
			while (j < MAX_ATTEMPT)
			{
				while (k < MAX_ATTEMPT)
				{
					while (l < MAX_ATTEMPT)
					{
						while (m < MAX_ATTEMPT)
						{
							while (n < MAX_ATTEMPT)
							{
								strActivation_code = new StringBuilder(6)
														.append(i) // digit1
						    							.append(j) // digit2
						    							.append(k) // digit3
						    							.append(l) // digit4
						    							.append(m) // digit5
						    							.append(n) // digit6
						    							.toString();

								String strCalculation = String.format("%06d",((((i * 10) + l) + ((j * 10) + m)) * k));
								int calculation_last_digit = Integer.parseInt(strCalculation.substring(strCalculation.length() - 1, strCalculation.length()));

						        if (n == calculation_last_digit) 
						        {
									n++;
						        	return strActivation_code;
						        }
						        else
						        {
						        	strActivation_code = "";
						        	n++;
						        }
							}
					        n = 0;
					        m++;
						}
						m = 0;
				        l++;
					}
					l = 0;
			        k++;
				}
				k = 0;
		        j++;
			}
			j = 0;
	        i++;
		}
		return strActivation_code;
	}
	
	private String generateNextResponseCode()
	{
		strResponse_code = "";
	    if (strActivation_code.length() == 6) 
	    {
	      try
	      {
	    	  // TODO: we don't need a second check, this should be optimized
	        int digit_1 = Integer.parseInt(strActivation_code.substring(0, 1));
	        int digit_2 = Integer.parseInt(strActivation_code.substring(1, 2));
	        int digit_3 = Integer.parseInt(strActivation_code.substring(2, 3));
	        int digit_4 = Integer.parseInt(strActivation_code.substring(3, 4));
	        int digit_5 = Integer.parseInt(strActivation_code.substring(4, 5));
	        int digit_6 = Integer.parseInt(strActivation_code.substring(5, 6));
	        strResponse_code = new StringBuilder(String.valueOf
		        		(new StringBuilder(String.valueOf
		        				(new StringBuilder
		        						(String.valueOf(new StringBuilder
		        								(String.valueOf(strNumSequence.substring(digit_4, digit_4 + 1)))
		        						.append(strNumSequence.substring(digit_6, digit_6 + 1)).toString()))
		        				.append(strNumSequence.substring(digit_1, digit_1 + 1)).toString()))
		        		.append(strNumSequence.substring(digit_3, digit_3 + 1)).toString()))
		        .append(strNumSequence.substring(digit_5, digit_5 + 1)).toString() 
		    + strNumSequence.substring(digit_2, digit_2 + 1);
	      }
	      catch (NumberFormatException localNumberFormatException)
	      {
	        return "";
	      }
	    }
	    return strResponse_code;
	}
}
